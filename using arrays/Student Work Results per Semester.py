'''Есть результаты работы студентов в семестре. Студентов выводить в порядке суммы их баллов. Требутеся вывести отсортированные результаты работ для каждого студента.

Данные вводятся как: student_id value

student_id принимает значения от 0 до N. value от 1 до 10

Пример входных данных: 0 3 0 5 1 3 1 2

Тут представленны данные о двух студента: 0 и 1. Сумма балов студента 0 - 8. Студента 1 - 5. Значит, сначала должны быть напечатаны результаты 0 студента, затем 1. Таким образом сначала надо вывести отсортированные результаты студента 0, затем студента 1:

5 3 3 2

Напомним, что у list в питоне есть встроенный метод sort и есть функция sorted. У них есть параметр key, который определяет по каким значениям будет сортироваться объект. Например код ниже будет сортировать лист по длинне его элементов. Так же есть параметр reverse.

a = ['###', '@', '??'] a.sort(key=lambda x: len(x)) a ['@', '??', '###'] a.sort(key=lambda x: len(x), reverse=True) ['###', '??', '@']

Что такое лямбда функция вы узнаете в дальнейшем (так же всегда есть сайт google). Для выполнения этого задания достаточно понять, на что надо заменить функцию len.

Формат входных данных
#.
В первой строке N - количество студентов. Далее идет какое-то количество строк (не равное N) с результатами студентов в формате: student_id value. 0 <= student_id < N. Значения разделены пробелом. Ввод заканчивается

Формат выходных данных
Вывести отсортированные результаты студентов в одну строку. Сначала печатаются результаты лучшего по сумме баллов студента, потом второго и так далее. Результаты в одну строку'''

students = int(input())
N = {}  # временный словарь
D = {}
x = 0
while True:
    # не актуально! мысль ... создать внутри цикла короткий список и добавлять в основной массив его вложенным массивом
    x = input()

    if x == str('#'):
        break

    B = x.split()

    stud = B[0]
    val = B[1]

    if stud.isdigit() and val.isdigit() and 0 <= int(stud) < students:
        stud = int(stud)
        val = int(val)
        # загоняем во временный словарь, чтобы потом сравнить есть ли такой же ключ в постоянном словре
        # и оборачиваем значение словаря в list, чтобы далее добавлять при совпадении другие значения
        N = {stud: [val]}

        if stud in D.keys():
            D[stud].append(val)
        else:
            D.update(N)

K = []  # ключи
for i in D.keys():
    K.append(i)

V = []  # значения
for i in D.values():
    i = sorted(i, reverse=True)  # сортируеми переворачиваем
    print(i)
    #
    V.append(i)


print(D)

print(V)
